package main

import (
	"bufio"
	"context"
	"errors"
	"github.com/lanyutc/blue"
	"github.com/lanyutc/blue/conf"
	"github.com/lanyutc/blue/naming/provider"
	"github.com/lanyutc/blue/util/kvfile"
	"google.golang.org/grpc"
	"net"
	"os"
	"strings"
	"sync"
	"time"
)

var (
	LOG       = blue.GetLogger("naming", 10)
	DLOG      = blue.GetDayLogger("naming", 30)
	cachefile = "./naming_cache"
	timeout   = 30 * time.Second
)

type ServerInfo struct {
	app           string
	set           string
	name          string
	addr          string
	isActive      bool
	lastHeartBeat time.Time
	update        chan bool
}

func (s ServerInfo) ActiveString() string {
	if s.isActive {
		return "active"
	} else {
		return "inactive"
	}
}

type NamingServer struct {
	svrs sync.Map
}

func (s *NamingServer) Registry(ctx context.Context, req *provider.RegistryReq) (*provider.RegistryRsp, error) {
	addr := req.GetNewServer().GetAddr()
	if _, existing := s.svrs.Load(addr); existing {
		LOG.Warn("Duplicate Addr(maybe server restart):", addr)
	}

	newSvr := &ServerInfo{
		app:           req.GetNewServer().GetApp(),
		set:           req.GetNewServer().GetSet(),
		name:          req.GetNewServer().GetName(),
		addr:          addr,
		isActive:      false, //等第一次心跳投入使用
		lastHeartBeat: time.Now(),
		update:        make(chan bool, 10),
	}
	s.svrs.Store(addr, newSvr)

	DLOG.Infof("Registry New Server|%+v", newSvr)
	return &provider.RegistryRsp{ServerList: s.ServerList()}, nil
}

func (s *NamingServer) HeartBeat(ctx context.Context, req *provider.HeartBeatReq) (*provider.HeartBeatRsp, error) {
	addr := req.GetAddr()
	v, existing := s.svrs.Load(addr)
	if !existing {
		return &provider.HeartBeatRsp{}, errors.New("Can Not Found Addr:" + addr)
	}

	if svr, ok := v.(*ServerInfo); ok {
		if !svr.isActive {
			s.NotifyUpdate()
		}
		svr.isActive = true
		svr.lastHeartBeat = time.Now()
	}

	return &provider.HeartBeatRsp{}, nil
}

func (s *NamingServer) UpdateInfo(req *provider.SubscribeReq, stream provider.Naming_UpdateInfoServer) error {
	addr := req.GetAddr()
	v, existing := s.svrs.Load(addr)
	if !existing {
		return errors.New("Can Not Found Addr:" + addr)
	}
	DLOG.Info("Begin Update:", addr)

	if svr, ok := v.(*ServerInfo); ok {
		for {
			select {
			case <-svr.update:
				if svr.isActive {
					err := stream.Send(&provider.PublishRsp{UpdateServerList: s.ServerList()})
					if err != nil {
						LOG.Error("UpdateInfo Err:", err, "|", svr.name, "|", svr.addr)
						break
					}
				}
			case <-time.After(timeout * 5):
				if !svr.isActive {
					DLOG.Info("Exit Update Stream:", svr.name, "|", svr.addr)
					return nil
				}
			}
		}
	}
	return nil
}

func (s *NamingServer) NotifyUpdate() {
	DLOG.Info("Notify Update")
	s.svrs.Range(func(k, v interface{}) bool {
		if svr, ok := v.(*ServerInfo); ok {
			svr.update <- true
		}
		return true
	})
}

func (s *NamingServer) LoadCache() {
	readerr := kvfile.ReadFileLines(cachefile, func(line string) bool {
		//去掉空格
		line = strings.TrimSpace(line)

		//跳过注释行
		if strings.HasPrefix(line, "//") {
			return true
		}

		//跳过空行
		if len(line) == 0 {
			return true
		}

		//竖线分割信息[addr|app|set|name|(in)active]
		pairs := strings.Split(line, "|")
		if len(pairs) == 5 {
			s.svrs.Store(pairs[0], &ServerInfo{
				app:           pairs[1],
				set:           pairs[2],
				name:          pairs[3],
				addr:          pairs[0],
				isActive:      pairs[4] == "active",
				lastHeartBeat: time.Now(),
				update:        make(chan bool, 10),
			})
			return true
		}

		LOG.Error("Require '|' splite server info:", line)
		return false
	})

	if readerr != nil {
		LOG.Error("Load CacheFile Err:", readerr)
	}
}

func (s *NamingServer) KeepSaveCache() {
	ticker := time.NewTicker(time.Second * 30)
	go func() {
		for range ticker.C {
			f, err := os.OpenFile(cachefile, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
			if err != nil {
				LOG.Error("SaveCache OpenFile Failed:" + err.Error())
			}
			defer f.Close()

			DLOG.Info("KeepSaveCache")
			writer := bufio.NewWriter(f)
			writer.WriteString("// Content generated by naming. DO NOT EDIT.\n")
			s.svrs.Range(func(k, v interface{}) bool {
				if svr, ok := v.(*ServerInfo); ok {
					//这里检查一下心跳超时的状态
					if svr.lastHeartBeat.Add(timeout * 2).Before(time.Now()) {
						s.svrs.Delete(k)
						DLOG.Info("Heart Beat TimeOut X2, Try Del:", svr.addr)
						return true
					} else if svr.lastHeartBeat.Add(timeout).Before(time.Now()) {
						if svr.isActive {
							s.NotifyUpdate()
						}
						svr.isActive = false
						DLOG.Info("Heart Beat TimeOut:", svr.addr)
					}
					writer.WriteString(svr.addr + "|" + svr.app + "|" + svr.set + "|" + svr.name + "|" + svr.ActiveString() + "\n")
				}
				return true
			})
			writer.Flush()
		}
	}()
}

func (s NamingServer) ServerList() (list []*provider.ServerInfo) {
	s.svrs.Range(func(k, v interface{}) bool {
		if svr, ok := v.(*ServerInfo); ok {
			if svr.isActive {
				list = append(list, &provider.ServerInfo{
					App:  svr.app,
					Set:  svr.set,
					Name: svr.name,
					Addr: svr.addr,
				})
			}
		}
		return true
	})
	return
}

func main() {
	cfg := conf.GetConfig()
	serve := &NamingServer{}
	serve.LoadCache()
	serve.KeepSaveCache()

	lis, errrpc := net.Listen("tcp", cfg.NamingServer)
	if errrpc != nil {
		panic("failed to listen:" + cfg.NamingServer)
	}

	grpcServer := grpc.NewServer()
	provider.RegisterNamingServer(grpcServer, serve)
	grpcServer.Serve(lis)
}
