package main

import (
	"bufio"
	"context"
	"os"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/lanyutc/blue"
	"github.com/lanyutc/blue/conf"
	"github.com/lanyutc/blue/pid_dispatch/dispatch"
	"github.com/lanyutc/blue/rpc"
	"github.com/lanyutc/blue/util/kvfile"
	"google.golang.org/grpc"
)

var (
	LOG       = blue.GetLogger("pid_dispatch", 10)
	DLOG      = blue.GetDayLogger("pid_dispatch", 30)
	cachefile = "./pid_dispatch_cache"
)

type ServerInfo struct {
	app  string
	addr string
	pid  int32
}

type PidDispatchServer struct {
	svrs   sync.Map
	pidIdx int32
}

func (s *PidDispatchServer) GetPid(ctx context.Context, req *dispatch.GetPidReq) (*dispatch.GetPidRsp, error) {
	addr := req.GetAddr()

	//如果已存在就取缓存
	if v, existing := s.svrs.Load(addr); existing {
		if svr, ok := v.(*ServerInfo); ok {
			DLOG.Infof("Server GetPid In Cache|%+v", svr)
			return &dispatch.GetPidRsp{Pid: svr.pid}, nil
		}
	}

	pid := atomic.AddInt32(&s.pidIdx, int32(1))
	newSvr := &ServerInfo{
		app:  req.GetApp(),
		addr: addr,
		pid:  pid,
	}
	s.svrs.Store(addr, newSvr)

	DLOG.Infof("New Server Pid|%+v", newSvr)
	return &dispatch.GetPidRsp{Pid: pid}, nil
}

func (s *PidDispatchServer) LoadCache() {
	readerr := kvfile.ReadFileLines(cachefile, func(line string) bool {
		//去掉空格
		line = strings.TrimSpace(line)

		//跳过注释行
		if strings.HasPrefix(line, "//") {
			return true
		}

		//跳过空行
		if len(line) == 0 {
			return true
		}

		//竖线分割信息[addr|app|pid]
		pairs := strings.Split(line, "|")
		if len(pairs) == 3 {
			pid, err := strconv.ParseInt(pairs[2], 10, 32)
			if err != nil {
				LOG.Error("Can Not Parse Pid|", line)
				return false
			}

			s.svrs.Store(pairs[0], &ServerInfo{
				app:  pairs[1],
				addr: pairs[0],
				pid:  int32(pid),
			})

			if int32(pid) > s.pidIdx {
				s.pidIdx = int32(pid)
			}
			return true
		}

		LOG.Error("Require '|' splite server info:", line)
		return false
	})

	if readerr != nil {
		LOG.Error("Load CacheFile Err:", readerr)
	}
}

func (s *PidDispatchServer) KeepSaveCache() {
	ticker := time.NewTicker(time.Second * 30)
	for range ticker.C {
		go func() {
			f, err := os.OpenFile(cachefile, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
			if err != nil {
				LOG.Error("SaveCache OpenFile Failed:" + err.Error())
			}
			defer f.Close()

			writer := bufio.NewWriter(f)
			writer.WriteString("// Content generated by pid_dispatch. DO NOT EDIT.\n")
			s.svrs.Range(func(k, v interface{}) bool {
				if svr, ok := v.(*ServerInfo); ok {
					writer.WriteString(svr.addr + "|" + svr.app + "|" + strconv.Itoa(int(svr.pid)) + "\n")
				}
				return true
			})
			writer.Flush()
		}()
	}
}

func main() {
	cfg := conf.GetConfig()
	serve := &PidDispatchServer{}
	serve.LoadCache()
	serve.KeepSaveCache()

	err := rpc.StartRpcServer(cfg.RPCAddr, func(s *grpc.Server) {
		dispatch.RegisterPidDispatchServer(s, serve)
	})
	if err != nil {
		panic(err)
	}

	rpc.ClientRpcMgrInstance()

	select {}
}
